<!-- !----------------------------------------------------- -->
<!-- !--------- APP SAMPLES CONTENT AND COMPONENTS -------- -->
<script>
  /**
   * Generates unique ID of specified length.
   * @param {number} length - The length of the unique ID. Default is 3.
   * @returns {number} - The generated unique ID.
   */
  const generateUniqueId = (length = 4) => {
    return parseInt(Math.ceil(Math.random() * Date.now()).toPrecision(length).toString().replace(".", ""))
  }

  /**
   * Generates a random boolean value.
   * @returns {boolean} - The generated boolean value.
   */
  const booleanGenerator = () => Math.random() >= 0.5;

  /**
   * Retrieves the color variables from local storage or returns default color variables.
   * @returns {object} - The color variables object.
   */
  const DESIGN_COLOR_VARIABLES =
    JSON.parse(localStorage.getItem('ColorVariables'))
    || {
      ['--primary-text-color']: '#F0ECE5',
      ['--secondary-text-color']: '#B6BBC4',
      ['--description-text-color']: '#949ca9',
      ['--primary-background-color']: '#191919',
    };

  /**
   * Retrieves a sample text.
   * @returns {array} - An array of sample text objects.
   */
  const GET_SAMPLE_TEXT = () => {
    const sample_text = [
      "Lorem, ipsum dolor sit amet consectetur adipisicing elit. Corporis mollitia ut sunt nulla ullam eum sed odio dolorem rem, laboriosam, suscipit facilis soluta assumenda nesciunt ratione. Sequi similique ab consectetur!",
      "Nulla architecto veniam rem voluptas, vitae nihil saepe sunt aliquam animi atque laboriosam molestias voluptates, pariatur corrupti perspiciatis tempora. Eum voluptate illo cum iusto aliquam voluptatem distinctio inventore ab iure.",
      "Cum rerum et, iusto placeat adipisci ut! Eveniet labore incidunt dolor vel est culpa ut velit accusamus dignissimos voluptatibus ipsa laudantium pariatur ullam tempora, porro dicta eius quos cumque nam!",
      "Vero exercitationem adipisci corrupti sapiente error. Voluptas veritatis porro harum voluptates repudiandae vel nam iure minima nisi! Molestiae esse asperiores dignissimos voluptatum dolorem rerum tenetur amet. Amet adipisci pariatur mollitia.",
      "Iusto necessitatibus impedit qui ducimus culpa assumenda neque blanditiis corrupti odio perspiciatis. Veniam quas quia accusamus nobis nihil praesentium debitis repellendus nostrum doloremque nemo. Accusamus itaque nemo amet provident tempore?",
      "Iure natus ipsa minus quas, blanditiis inventore cupiditate officia iusto pariatur autem voluptates aliquid nisi temporibus voluptatum eum harum obcaecati quidem voluptate. Temporibus odio, explicabo minus in consequatur obcaecati laborum.",
      "Ducimus commodi rem, et sapiente delectus aspernatur, qui ratione hic ullam quisquam deleniti sint, recusandae vel consequatur mollitia doloremque. Nam, fugiat. Labore laudantium dolor quaerat officia rem animi ab cupiditate?",
      "Architecto, laborum maxime voluptatibus consequatur delectus odit at! Aliquam porro sapiente sequi obcaecati nulla, ea blanditiis eveniet earum praesentium reprehenderit deleniti debitis totam doloribus soluta explicabo perferendis. Amet, impedit fugit.",
      "Iste delectus reprehenderit itaque, eligendi soluta dolorum esse quia mollitia at! Provident corporis nam impedit saepe quas quibusdam deleniti, reiciendis earum perferendis pariatur qui cupiditate. Consequatur eaque error voluptatibus blanditiis.",
      "Praesentium vitae earum minima in quis eaque pariatur, optio officia repellat quae possimus unde repellendus, beatae deleniti, harum autem sequi nulla itaque. Fugit soluta eaque omnis amet quasi accusantium hic!"
    ]

    return [
      {
        ['primary-header-text']: sample_text[Math.floor(Math.random() * sample_text.length)].slice(0, Math.max(30, Math.floor(Math.random() * 60)))
      },
      ...Array.from({ length: Math.max(1, Math.floor(Math.random() * 3)) }, () => {
        return {
          ['primary-body-text']: sample_text[Math.floor(Math.random() * sample_text.length)]
        }
      })
    ]
  }

  /**
   * Retrieves a sample media.
   * @returns {object} - The sample media object.
   */
  const GET_SAMPLE_MEDIA = () => {
    const sample_media = [
      {
        type: 'image',
        url: 'https://images.unsplash.com/photo-1470252649378-9c29740c9fa8?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
        description: ''
      }, {
        type: 'image',
        url: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?q=80&w=2074&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-landscape-of-a-large-lake-during-sunset-from-the-air-4998-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-meadow-surrounded-by-trees-on-a-sunny-afternoon-40647-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-turquoise-blue-water-bay-from-above-5008-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-aerial-shot-of-a-small-isthmus-44399-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-countryside-meadow-4075-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-landscape-of-a-lake-during-a-red-sunset-5002-large.mp4',
        description: ''
      }
    ]

    return sample_media[Math.floor(Math.random() * sample_media.length)];
  }

  const SKEW_OPTIONS_TOP = ['a', 'b', 'none'];
  const SKEW_OPTIONS_BOTTOM = ['a', 'b', 'none'];
  const TEXT_ANIMATIONS = ['slide', 'opacity', 'none'];
  const TEXT_CONTAINER = ['left', 'right', 'center', 'none'];
  const TEXT_ALIGNMENT = ['left', 'right', 'center'];
  const TEXT_TYPES = ['primary-header-text', 'secondary-header-text', 'primary-body-text'];
  const COMPONENTS_TYPES = ['PARALLAX_BLEND', 'FIXED', 'PARALLAX'];

  /**
   * Generates the content for different components based on the component type.
   * @param {string} componentType - The type of the component.
   * @returns {object} - The generated content object.
   */
  const COMPONENTS_CONTENT_GENERATOR = (componentType) => {
    switch (componentType) {
      case 'PARALLAX_BLEND':
        return {
          elementExpanded: false,
          options: {
            blur: booleanGenerator(),
            shadow: booleanGenerator(),
            textAnimation: TEXT_ANIMATIONS[Math.floor(Math.random() * TEXT_ANIMATIONS.length)],
            textContainer: TEXT_CONTAINER[Math.floor(Math.random() * TEXT_CONTAINER.length)],
            textAlignment: TEXT_ALIGNMENT[Math.floor(Math.random() * TEXT_ALIGNMENT.length)],
          },
          media: GET_SAMPLE_MEDIA(),
          text: GET_SAMPLE_TEXT()
        }
      case 'FIXED':
        return {
          elementExpanded: false,
          options: {
            insetShadow: booleanGenerator(),
            textAnimation: TEXT_ANIMATIONS[Math.floor(Math.random() * TEXT_ANIMATIONS.length)],
            textAlignment: TEXT_ALIGNMENT[Math.floor(Math.random() * TEXT_ALIGNMENT.length)],
          },
          media: GET_SAMPLE_MEDIA(),
          text: GET_SAMPLE_TEXT()
        }
      case 'PARALLAX':
        return {
          options: {
            blur: booleanGenerator(),
            shadow: booleanGenerator(),
            textAnimation: TEXT_ANIMATIONS[Math.floor(Math.random() * TEXT_ANIMATIONS.length)],
            textAlignment: TEXT_ALIGNMENT[Math.floor(Math.random() * TEXT_ALIGNMENT.length)],
          },
          media: GET_SAMPLE_MEDIA(),
          text: GET_SAMPLE_TEXT()
        }
      default:
        throw new Error('Invalid data type at COMPONENTS_CONTENT_GENERATOR');
    }
  };

  /**
   * Generates the object for different components based on the component type.
   * @param {string} componentType - The type of the component.
   * @returns {object} - The generated component object.
   */
  const COMPONENTS_OBJECT_GENERATOR = (componentType) => {
    switch (componentType) {
      case 'PARALLAX_BLEND':
        return {
          id: generateUniqueId(),
          componentType: componentType,
          expanded: false,
          content: Array.from({ length: Math.max(2, Math.floor(Math.random() * 5)) }, () => COMPONENTS_CONTENT_GENERATOR(componentType))
        }
      case 'FIXED':
        return {
          id: generateUniqueId(),
          expanded: false,
          componentType: componentType,
          options: {
            skewTop: SKEW_OPTIONS_TOP[Math.floor(Math.random() * SKEW_OPTIONS_TOP.length)],
            skewBottom: SKEW_OPTIONS_BOTTOM[Math.floor(Math.random() * SKEW_OPTIONS_BOTTOM.length)],
            shadow: booleanGenerator(),
            flex: booleanGenerator(),
          },
          content: Array.from({ length: Math.max(2, Math.floor(Math.random() * 4)) }, () => COMPONENTS_CONTENT_GENERATOR(componentType))
        }
      case 'PARALLAX':
        return {
          id: generateUniqueId(),
          componentType: componentType,
          expanded: false,
          ...COMPONENTS_CONTENT_GENERATOR(componentType)
        }
      default:
        throw new Error('Invalid data type at COMPONENTS_OBJECT_GENERATOR');
    }
  };

  /**
   * Retrieves the stored components from local storage or generates new components.
   * @returns {array} - An array of components.
   */
  const localStorageComponents = JSON.parse(localStorage.getItem('StoredComponents'));
  const COMPONENTS_DATA =
    localStorageComponents ||
    COMPONENTS_TYPES.map(component => COMPONENTS_OBJECT_GENERATOR(component));
</script>

<!-- !----------------------------------------------------- -->
<!-- !------------------- APP STYLES ---------------------- -->
<style type="text/css">
  * {
    padding: 0;
    margin: 0;
    box-sizing: border-box;
  }

  .app .layout::-webkit-scrollbar {
    width: 5px;
  }

  .app .layout::-webkit-scrollbar-track {
    background: var(--primary-background-color);
  }

  .app .layout::-webkit-scrollbar-thumb {
    background: var(--description-text-color);
  }

  .app {
    display: flex;
    overflow: hidden;
    height: 100vh;
  }

  .componentExpanded {
    border: 5px solid #ff5200;
    position: relative !important;
  }

  .componentExpanded.parallax-header .text,
  .componentExpanded.fixed .content {
    border: 5px solid #ff5200;
  }

  .componentExpanded::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    background-color: #ff290021;
    z-index: 99999999999 !important;
  }

  .app #wrapper {
    width: 100%;
    height: 100%;
    overflow: auto;
    overflow-y: overlay;
  }

  .app .side-panel {
    position: sticky;
    background: #191919;
    min-width: 400px;
    box-shadow: 0 0 8px black;
    z-index: 9999999999;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    max-width: 500px;
    overflow: hidden;
    color: white;
    padding-left: 5px;
  }

  .app .side-panel .controls {
    margin-top: auto;
  }

  .app .side-panel .design {
    padding: 10px;
    border-radius: 8px;
    margin: 5px;
    background-color: rgb(43, 42, 42);
  }

  .app .side-panel .design .theme-color {
    margin: 0 40px;
    text-transform: capitalize;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .app .side-panel .layout {
    overflow-x: hidden;
    overflow-y: scroll;
    height: 100%;
    scrollbar-width: thin;
  }

  .app .side-panel .layout .header {
    cursor: grab;
  }


  .app .side-panel .layout .component {
    margin: 10px 5px;
    background-color: rgb(43, 42, 42);
    border-radius: 8px;
    border: 2px solid #8080806b;
  }

  .app .side-panel .layout .component .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
  }

  .app .side-panel .layout .component .header .options {
    display: flex;
    float: right;
  }

  .app .side-panel .layout .component .header .options .option {
    padding: 2px 7px;
    cursor: pointer;
  }

  .app .side-panel .layout .component .component-container {
    display: none;
  }

  .app .side-panel .layout .component .component-container.active {
    margin: 0 10px 10px;
    display: block;
  }

  .app .side-panel .layout .component .component-container .component-content {
    padding: 5px 10px;
    margin-bottom: 10px;
    background-color: #191919;
    border: 2px solid #8080806b;
    border-radius: 5px;
  }

  .app .side-panel .layout .component .component-container .component-content .content.active {
    display: none;
  }

  .app .side-panel .layout .component .component-container .component-content .options {
    padding: 5px;
    border: 2px solid grey;
    border-radius: 5px;
    margin: 5px 0;
  }

  .app .side-panel .layout .component .component-container .component-content .options .option {
    padding: 5px 0;
  }

  .app .side-panel .layout .component .component-container .component-content .options button {
    padding: 2px 4px;
    cursor: pointer;
  }

  .app .side-panel .layout .component .component-container .component-content .options h4 {
    text-transform: capitalize;
    padding: 5px 0;
  }

  .button {
    background: grey;
    margin: 5px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
  }
</style>

<!-- !----------------------------------------------------- -->
<!-- !-------------------- DOM BODY ----------------------- -->
<div class="app">
  <div id="wrapper">
    <style type="text/css">
      :root {
        --primary-text-color: #F0ECE5;
        --secondary-text-color: #B6BBC4;
        --description-text-color: #949ca9;

        --primary-background-color: #191919;
        --secondary-background-color: #3a5a40;

        --background-blend-delay: .5s;
        --text-animation-slide-delay: 1s;
        --text-animation-opacity-delay: 1.2s;

        --content-max-width: 1000px;
      }

      /* ----- global text ----- */
      .primary-header-text {
        color: var(--primary-text-color);
        padding: 15px 20px;
        margin: 0;
        font-size: 28px;
      }

      .secondary-header-text {
        color: var(--primary-text-color);
        font-size: 22px;
        padding: 15px 20px;
      }

      .primary-body-text {
        margin: 0;
        padding: 10px 20px;
        color: var(--secondary-text-color);
        font-size: 16px;
      }

      .description {
        font-size: 16px;
        color: var(--description-text-color);
        padding: 10px 30px;
      }

      .parallax .description,
      .parallax-header .description {
        position: absolute !important;
        bottom: 20px !important;
        right: 20px;
        z-index: 9999999;
      }

      .wrapper-body {
        background-color: var(--primary-background-color);
      }

      /* ----- splash laoder ----- */
      .loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        z-index: 999999999;
        backdrop-filter: blur(10px);
        background-color: var(--primary-background-color);
        opacity: 1;
        transition: all 1s ease-in;
      }

      .loader.disabled {
        opacity: 0;
        backdrop-filter: blur(0);
      }

      /* ----- animation classes ----- */
      .animate-bg-shadow:after,
      .animate-bg-blur:after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .animate-bg-shadow:after {
        background: rgba(0, 0, 0, .5);
        opacity: 0;
        transition: opacity var(--background-blend-delay) ease-in;
      }

      .animate.animate-bg-shadow:after {
        opacity: 1;
      }

      .animate-bg-blur:after {
        -webkit-backdrop-filter: blur(0px);
        backdrop-filter: blur(0px);
        transition: all var(--background-blend-delay) ease-in;
      }

      .animate.animate-bg-blur:after {
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }

      /* ----- text opacity animation classes ----- */
      .text .opacity {
        opacity: 0;
        scale: .9;
        transition: scale, opacity;
        transition-duration: var(--text-animation-opacity-delay);
        transition-timing-function: ease-in-out;
      }

      .text .opacity.animate {
        opacity: 1;
        scale: 1;
      }

      /* ----- text slide animation classes ----- */
      .slide {
        transform: translate3d(-100%, 0, 0);
        opacity: .5;
        transition: all var(--text-animation-slide-delay) ease;
      }

      .slide.animate {
        transform: translate3d(0, 0, 0);
        opacity: 1;
      }

      .slide.out:not(.animate) {
        transform: translate3d(100%, 0, 0);
        opacity: 1;
      }

      /* ---------------- header ---------------- */
      .parallax-header {
        position: relative;
      }

      .parallax-header .text-content {
        margin-top: -100vh;
      }

      .parallax-header .background-content {
        position: sticky;
        top: 0px;
        height: 100vh;
      }

      .parallax-header .background-content .media img,
      .parallax-header .background-content .media video {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        transform: translate(-50%, -50%);
        -o-object-fit: cover;
        object-fit: cover;
        -o-object-position: center;
        object-position: center;
      }

      .parallax-header .text-content .text {
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2em;
        position: relative;
        overflow: hidden;
      }

      .parallax-header .text-content .text .container:not(.active) {
        max-width: var(--content-max-width);
      }

      .parallax-header .text-content .text .container.active {
        background: rgba(0, 0, 0, 0.5);
        padding: 10px 20px;
        min-width: 300px;
        max-width: 600px;
        opacity: 1;
        width: 80%;
      }

      .parallax-header .text-content .text .container.active.opacity {
        opacity: 0;
        scale: .9;
        transition: scale, opacity;
        transition-duration: var(--text-animation-opacity-delay);
        transition-timing-function: ease-in-out;
      }

      .parallax-header .text-content .text.animate .container.active.opacity {
        /* transform: translateX(-9vw); */
        opacity: 1;
        scale: 1;
      }

      .parallax-header .text-content .text .container.active.slide {
        transition: transform .3s ease-in;
      }

      .parallax-header .text-content .text .container.active.slide.left {
        transform: translateX(-100%);
      }

      .parallax-header .text-content .text .container.active.slide.right {
        transform: translateX(100%);
      }

      .parallax-header .text-content .text.animate .container.active.center {
        transform: translateX(0);
      }

      .parallax-header .text-content .text.animate .container.active.left {
        transform: translateX(-9vw);
      }

      .parallax-header .text-content .text.animate .container.active.right {
        transform: translateX(9vw);
      }

      /* ---------------- fixed ---------------- */
      .fixed {
        z-index: 2;
        position: relative;
      }

      .fixed.shadow {
        filter: drop-shadow(0 0 12px rgba(0, 0, 0, .8));
      }

      .fixed .container {
        width: 100%;
        height: fit-content;
        background: var(--primary-background-color);
        padding: 20px 0;
        overflow: hidden;
      }

      .fixed .container .content {
        width: 100%;
        margin: 0 auto;
        max-width: var(--content-max-width);
      }

      .fixed .container .flex {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        flex-direction: row;
        justify-content: center;
        max-width: var(--content-max-width);
        margin: 0 auto;
        column-gap: 20px;
      }

      .fixed .container .flex .content {
        flex: 1 1 400px;
        align-self: flex-start;
      }

      .fixed .container .content video,
      .fixed .container .content img {
        width: 100%;
      }

      /* ---------------- parallax ---------------- */
      .parallax {
        position: relative;
        width: 100%;
        height: 100vh;
        overflow: hidden;
      }

      .parallax .content {
        position: absolute;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        clip: rect(0 auto auto 0);
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
      }

      .parallax .content .media {
        position: fixed;
        top: 0;
        left: 0;
        display: block;
        width: 100%;
        height: 100%;
        background-repeat: no-repeat;
        background-attachment: scroll;
        background-position: 50%;
        background-size: cover;
      }

      .parallax .content .text {
        position: absolute;
        top: 50%;
        left: 50%;
        z-index: 1;
        box-sizing: border-box;
        width: 100%;
        max-width: var(--content-max-width);
        padding: 0 10px 0 15px;
        margin: 0 auto;
        transform: translate(-50%, -50%);
      }

      .parallax .content .media img,
      .parallax .content .media video {
        -o-object-fit: cover;
        object-fit: cover;
        -o-object-position: center center;
        object-position: center center;
        width: 100%;
        height: 100vh;
      }

      @media only screen and (min-width: 600px) {
        .primary-header-text {
          font-size: 32px;
        }

        .secondary-header-text {
          font-size: 24px;
        }

        .primary-body-text {
          font-size: 18px;
        }

        .fixed .content .media {
          position: relative;
        }

        .fixed .content .media.insetShadow:after {
          content: '';
          top: 0;
          left: 0;
          position: absolute;
          width: 100%;
          height: 100%;
          box-shadow: inset 0 0 8px 20px var(--primary-background-color);
        }
      }
    </style>
    <div class="wrapper-body">
      <div class="loader"></div>
    </div>

    <script>
      function initObserver() {
        function handleIntersection(entries, observer) {
          entries.forEach(entry => {
            const target = entry.target;
            const inViewPercent = entry.intersectionRatio;
            const opacityVal = inViewPercent > 0.90 ? 1 : inViewPercent;

            const boundingBox = entry.target.getBoundingClientRect();
            const elementCenter = boundingBox.top + boundingBox.height / 2;
            const viewportCenter = window.innerHeight / 2;

            if (elementCenter < viewportCenter) {
              target.classList.add('out');
              target.classList.remove('in');
            } else {
              target.classList.add('in');
              target.classList.remove('out');
            }

            const headerParallaxBackground = target.id ? document.querySelector(`#${target.id}`) : null;

            if (headerParallaxBackground) {
              if (target.classList.contains('control-opacity') && target.classList.contains('in')) {
                headerParallaxBackground.style.opacity = opacityVal;
              }
            }

            if (entry.isIntersecting) {
              target.classList.add('animate');
              headerParallaxBackground && headerParallaxBackground.classList.add('animate');
            } else {
              target.classList.remove('animate');
              headerParallaxBackground && headerParallaxBackground.classList.remove('animate');
            }
          });
        }

        const options = {
          threshold: Array.from({ length: 41 }, (_, index) => Number((index * 0.025).toFixed(2))),
        };

        const observer = new IntersectionObserver(handleIntersection, options);

        document.querySelectorAll('.observe').forEach(function (el) {
          observer.observe(el);
        });
      }

      document.addEventListener('DOMContentLoaded', function () {
        initObserver();

        const loader = document.querySelector('.loader');
        setTimeout(() => loader.classList.add('disabled'), 100);
        setTimeout(() => loader.remove(), 1100);
      })
    </script>
  </div>

  <div class="side-panel">
    <div class="design"></div>
    <div class="layout"></div>
    <div class="controls"></div>
  </div>
</div>

<!-- !----------------------------------------------------- -->
<!-- !---------------- APP DOM GENERATOR ------------------ -->
<script>
  function extractTextContent(data, textAnimation = 'none') {
    let INNERTEXT = '';

    if (!data) return '';

    const textAnimationClass = textAnimation !== 'none' ? ` observe ${textAnimation}` : '';

    data.forEach(text => {
      const [key, value] = Object.entries(text)[0];
      INNERTEXT += `
        <div contenteditable="true" class='${key}${textAnimationClass}'>
          ${value}
        </div>`;
    });
    return INNERTEXT;
  }

  function populateMediaContent(data, options) {
    const insetShadow = options?.insetShadow;
    if (!data || !data.url) return '';
    const mediaDescription = data.description ? `<p contenteditable="true" class="description">${data.description}</p>` : '';

    const mediaContent = data.type?.includes('video')
      ? `<div class="media${insetShadow ? ' insetShadow' : ''}">
            <video autoplay loop muted playsinline preload="none" loading="lazy">
              <source src="${data.url}" type="${data.type}" />Your browser does not support the video tag.
            </video>
          </div>`
      : `
          <div class="media${insetShadow ? ' insetShadow' : ''}">
            <img alt="${data.description}" src="${data.url}" preload="none" loading="lazy" decoding="async"/>
          </div>`;

    return `<div class='media-content'>${mediaContent}${mediaDescription}</div>`
  }

  function exctractFixedContent(data) {
    let CONTENT = '';
    data.content.forEach(val => {
      CONTENT += `
        <div class='content targetableElement'>
          ${populateMediaContent(val.media, val.options)}
          <div class='text' style="text-align: ${val.options.textAlignment}">
            ${extractTextContent(val.text, val.options?.textAnimation)}
          </div>
        </div>`
    });
    return CONTENT;
  }

  function initDOMcontentData(components) {
    const wrapper = document.querySelector('.wrapper-body');

    let __DOM__ = '';

    for (let component of components) {
      const isExpanded = component.expanded ? ' componentExpanded' : '';

      switch (component.componentType) {
        case 'PARALLAX_BLEND':
          let BACKGROUND = '', CONTENT = '';

          component.content.forEach((val, idx) => {
            const shadow = val.options?.shadow ? ' animate-bg-shadow' : '';
            const blur = val.options?.blur ? ' animate-bg-blur' : '';
            const textContainer = val.options?.textContainer !== 'none'
              ? ` active ${val.options?.textContainer} ${val.options?.textAnimation !== 'none' ? val.options?.textAnimation : ''}`
              : ''
            const textAnimation = textContainer ? false : val.options?.textAnimation;


            BACKGROUND += `
              <div class='background${shadow}${blur}' id='o${component.id}-${idx}'>
                ${populateMediaContent(val.media, val.options)}
              </div>`;
            CONTENT += `
              <div class='text observe${idx ? ' control-opacity' : ''} targetableElement' id='o${component.id}-${idx}' style="text-align: ${val.options.textAlignment}">
                ${val.text?.length ? `
                  <div class="container${textContainer}">
                    ${extractTextContent(val.text, textAnimation)}
                  </div>
                `: ''}
              </div>`;
          });

          __DOM__ += `
            <div class='parallax-header${isExpanded}' component-id='${component.id}'>
              <div class='background-content'>${BACKGROUND}</div>
              <div class='text-content'>${CONTENT}</div>
            </div>`;
          break;

        case 'FIXED':
          const containerShadow = component.options.shadow;
          const containerFlex = component.options.flex;
          const skewTop = component.options.skewTop;
          const skewBottom = component.options.skewBottom;

          const skewTopOptions = {
            a: '0 75px, 100% 0',
            b: '0 0, 100% 75px',
            none: '0 0, 100% 0'
          };

          const skewBottomOptions = {
            a: '100% calc(100% - 75px), 0 100%',
            b: '100% 100%, 0 calc(100% - 75px)',
            none: '100% 100%, 0 100%'
          };

          const skewStyle = (skewTop === 'none' && skewBottom === 'none')
            ? '' : `style='clip-path: polygon(${skewTopOptions[skewTop]}, ${skewBottomOptions[skewBottom]});
            ${skewTop === 'none' ? '' : 'margin-top: -80px; padding-top: 85px;'} 
            ${skewBottom === 'none' ? '' : 'margin-bottom: -80px; padding-bottom: 85px;'}'` //? --- padding to offset the clip cut

          __DOM__ += `
            <div class='fixed${containerShadow ? ' shadow' : ''}${isExpanded}' component-id='${component.id}'>
              <div class="container" ${skewStyle}>
                ${containerFlex
              ? `<div class='flex'>
                    ${exctractFixedContent(component)}
                  </div>`
              : exctractFixedContent(component)}
              </div>
            </div>`;
          break;

        case 'PARALLAX':
          const shadow = component.options.shadow ? ' animate-bg-shadow' : '';
          const blur = component.options.blur ? ' animate-bg-blur' : '';

          __DOM__ += `
            <div class="parallax${isExpanded}" component-id='${component.id}'>
              <div class="content observe${shadow}${blur}">
                ${populateMediaContent(component.media)}
                ${component.text ? `
                  <div class="text" style="text-align: ${component.options.textAlignment}">
                    ${extractTextContent(component.text, component.options.textAnimation)}
                  </div>
                  ` : ''}
              </div>
            </div>`;
          break;
        default:
          throw new Error('Invalid component type at initDOMcontentData');
      }
    }

    wrapper.insertAdjacentHTML('afterbegin', __DOM__);
  }

  function domInit(data) {
    initDOMcontentData(data)
    initObserver();
  }
</script>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>

<!-- !----------------------------------------------------- -->
<!-- !------------------- APP CONTROLS -------------------- -->
<script>
  function EMPTYDOMCOMPONENTS() {
    $('.side-panel .layout').empty();
    $('.wrapper-body').empty();
  }

  function REPOPULATEDOM() {
    const components = COMPONENTS_DATA;
    localStorage.setItem('StoredComponents', JSON.stringify(components));

    initSidePanel(components);
    domInit(components);
    checkExpandableElement(components);
  }

  function checkExpandableElement(components) {
    components.forEach(component => {
      if (component.content) {
        component.content.forEach((content, index) => {
          if (content.elementExpanded) {
            $(`[component-id="${component.id}"]`).removeClass('componentExpanded')
            $(`[component-id="${component.id}"] .targetableElement:nth-child(${index + 1})`).addClass('componentExpanded')
          }
        })
      }
    });
  }

  function clearFromLocalStorage(item) {
    switch (item) {
      case 'StoredComponents':
        $('.clearStoredComponents').remove()
        localStorage.removeItem(item)
        break;
      case 'ColorVariables':

        break;
      default:
        throw new Error('Invalid item at clearFromLocalStorage');
    }
  }

  const deleteElement = (componentID, elementIndex, elementType, textIndex) => {
    const components = COMPONENTS_DATA;
    const componentIndex = components.findIndex(x => x.id === componentID)

    EMPTYDOMCOMPONENTS();

    if (elementType === 'content') {
      components[componentIndex].content.splice(elementIndex, 1);
    } else if (elementType === 'text' && textIndex !== undefined) {
      if (components[componentIndex].content) {
        components[componentIndex].content[elementIndex][elementType].splice(textIndex, 1)
      } else {
        components[componentIndex][elementType].splice(textIndex, 1)
      }
    } else {

      // ? -------------- got to be a better way right ???? -------------
      // ! --------------------------------------------------------------
      if (elementIndex !== undefined) {
        delete components[componentIndex].content[elementIndex][elementType.toLowerCase()];
      } else {
        delete components[componentIndex][elementType.toLowerCase()];
      }
    }

    REPOPULATEDOM();
  }

  const addAdditionalText = (componentID, textType, textIndex) => {
    const components = COMPONENTS_DATA;
    const target = components[components.findIndex(x => x.id === Number(componentID))]

    if (target.text) {
      target.text.push({ [textType.value]: 'Text here...' })
    } else {
      target.content[textIndex].text.push({ [textType.value]: 'Text here...' })
    }

    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  /**
   * Updates the values of a component based on the provided parameters.
   * @param {string} componentID - The ID of the component.
   * @param {string} dataType - The type of data to be updated (options, text, media).
   * @param {string} key - The key of the value to be updated.
   * @param {any} newValue - The new value to be assigned.
   * @param {number} elementIndex - The index of the element in the component's content array (optional).
   * @param {number} textIndex - The index of the text element in the component's content array (optional).
   * @throws {Error} If an invalid data type is provided.
   */
  const updateComponentValues = (componentID, dataType, key, newValue, elementIndex, textIndex) => {
    const targetObject = COMPONENTS_DATA.find(x => x.id === componentID);

    let targetElement;

    //! ------ honestly not the best way but it works for now
    if (elementIndex !== undefined) {
      targetElement = targetObject.content[elementIndex][dataType];
    } else {
      targetElement = targetObject[dataType];
    }

    EMPTYDOMCOMPONENTS();

    switch (dataType) {
      case 'options':
        if (typeof targetElement[key] === 'boolean') {
          targetElement[key] = !targetElement[key];
        } else {
          targetElement[key] = newValue;
        }
        break;
      case 'text':
        targetElement[textIndex][key] = newValue.value;
        break;
      case 'media':
        targetElement[key] = newValue;
        break;
      default:
        throw new Error('Invalid data type at updateComponentValues');
    }

    REPOPULATEDOM();
  }

  const addComponent = (selectedElement) => {
    COMPONENTS_DATA.push(COMPONENTS_OBJECT_GENERATOR(selectedElement.value));
    selectedElement.value = ''

    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const deleteComponent = (componentID) => {
    const components = COMPONENTS_DATA;
    const targetIndex = components.findIndex(x => x.id === Number(componentID));

    components.splice(targetIndex, 1)
    $(`.layout #${componentID}`).remove();
    $(`[component-id="${componentID}"]`).remove();

    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const scrollToComponent = (componentID, nested = '') => {
    const container = document.querySelector(`[component-id="${componentID}"] ${nested}`);

    if (container) {
      container.scrollIntoView({ behavior: 'smooth' });
      $(container).toggleClass('componentExpanded');
    }
  }

  const addMoreContent = (componentID, componentType) => {
    const components = COMPONENTS_DATA;
    const target = components[components.findIndex(x => x.id === Number(componentID))];

    target.content.push(COMPONENTS_CONTENT_GENERATOR(componentType))
    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const toggleExpand = (componentID, type, contentIndex) => {
    const components = COMPONENTS_DATA;

    $('.side-panel .layout').empty();
    $(`.componentExpanded`).removeClass('componentExpanded');

    switch (type) {
      case 'component':
        components.forEach(x => {
          if (componentID !== x.id) x.expanded = false;
          else x.expanded = !x.expanded;
        });

        if (components.find(x => x.id === componentID).expanded) {
          scrollToComponent(componentID)
        }
        break;
      case 'container':
        const selectedElement = components.find(x => x.id === componentID)

        if (selectedElement.hasOwnProperty('content')) {
          selectedElement.content.forEach((x, idx) => {
            if (contentIndex !== idx) x.elementExpanded = false;
            else x.elementExpanded = !x.elementExpanded;
          })
        }

        const nestedElement = `.targetableElement:nth-child(${contentIndex + 1})`;

        if (selectedElement.content[contentIndex].elementExpanded) {
          scrollToComponent(componentID, nestedElement)
        }
        break;
      default:
        throw new Error(`Invalid toggle type: ${type}`)
    }
    localStorage.setItem('StoredComponents', JSON.stringify(components));

    initSidePanel(components);
  }

  const updateColor = (data, target) => {
    DESIGN_COLOR_VARIABLES[target] = data.value
    $('.wrapper-body').css(target, data.value)

    localStorage.setItem('ColorVariables', JSON.stringify(DESIGN_COLOR_VARIABLES));
  }

  /**
   * Extracts component options based on the provided parameters.
   *
   * @param {string} componentID - The ID of the component.
   * @param {string} title - The title of the component options.
   * @param {Object|Array} data - The data object or array containing the options.
   * @param {number} elementIndex - The index of the element.
   * @returns {string} - The HTML code representing the component options.
   */
  const extractComponentOptions = (componentID, title, data, elementIndex) => {
    if (!data) return ''

    let content = '';

    if (!Array.isArray(data)) {
      Object.entries(data).forEach(([key, value]) => {

        const BOOLEAN_KEYS_MAP = [
          'blur', 'type', 'shadow', 'insetShadow', 'flex'
        ].reduce((a, v) => ({ ...a, [v]: v }), {});

        const DROPDOWN_KEYS_MAP = [
          'textAnimation', 'textAlignment', 'textContainer', 'type', 'skewTop', 'skewBottom'
        ].reduce((a, v) => ({ ...a, [v]: v }), {});

        const TEXT_FIELD_KEYS_MAP = [
          'description', 'url'
        ].reduce((a, v) => ({ ...a, [v]: v }), {});

        let dataType = title;
        if (title === 'container options') dataType = 'options'; //? unique case ---

        switch (key) {
          case BOOLEAN_KEYS_MAP[key]: //? ----- boolean keys -----
            content += `
              <div class='option'>
                ${key}: 
                <button onclick="updateComponentValues(${componentID}, '${dataType}', '${key}', ${!value}, ${elementIndex})">
                  ${value}
                </button>
              </div>`;

            break;
          case DROPDOWN_KEYS_MAP[key]: //? ----- dropdown keys -----
            const dropdownValuesMap = {
              textContainer: TEXT_CONTAINER,
              textAnimation: TEXT_ANIMATIONS,
              textAlignment: TEXT_ALIGNMENT,
              type: ['image', 'video/mp4'],
              skewTop: SKEW_OPTIONS_TOP,
              skewBottom: SKEW_OPTIONS_BOTTOM,
            };

            let optionsDom = '';
            dropdownValuesMap[key].forEach(val => {
              optionsDom += `
                <option value=${val} ${val === data[key] ? 'selected' : ''}>${val}</option>`
            })

            content += `
              <div class='option'>
                <label for="${key}">${key}:</label>
                <select onchange="updateComponentValues(${componentID}, '${dataType}', '${key}', this.options[this.selectedIndex].value, ${elementIndex})">
                  ${optionsDom}
                </select>
              </div>`

            break;
          case TEXT_FIELD_KEYS_MAP[key]: //? ----- text field keys -----
            content += `
              <div class='option'>
                <p style='display: inline-block'>${key}:</p>
                <input type="text" value="${value}" onchange="updateComponentValues(${componentID}, '${dataType}', '${key}', this.value, ${elementIndex})">
              </div>`
            break
          default:
            throw new Error(`Invalid form input type: ${key}`)
        }
      })
    } else if (Array.isArray(data) && title === 'text') {
      data.forEach((text, idx) => {
        const [key, value] = Object.entries(text)[0];
        content += `
            <div class='option' ${idx}> 
              <label for="text">${key}:</label>
              <input type="text" value="${value}" onchange="updateComponentValues(${componentID}, '${title}', '${key}', this, ${elementIndex}, ${idx})">
              <button style='float: right;' onclick="deleteElement(${componentID}, ${elementIndex}, '${title}', ${idx})">x</button>
            </div>
          `
      })
    } else {
      throw new Error(`Invalid data type: ${title}`)
    }

    let textOptions = ''
    TEXT_TYPES.forEach(x => {
      textOptions += `<option value='${x}'>${x}</option>`
    })

    return `
        <div class="options ${title.toLowerCase().replace(' ', '-')}">
          <h4>${title} ${!['options', 'container options'].includes(title) ?
        `<button style="float: right;" onClick='deleteElement(${componentID}, ${elementIndex}, "${title}")'>x</button>` : ''}</h4> 
          ${content}
          ${title === 'text'
        ? `
          <div class='option'>
            <label for="${title}">Add Text:</label>
            <select onchange="addAdditionalText(${componentID}, this, ${elementIndex})">
              <option value="" selected disabled>Choose here</option>
              ${textOptions}
            </select>
          </div>
            `
        : ''}
        </div>`
  }

  const initSidePanel = (data) => data.forEach((val, idx) => populateSidePanelLayoutComponents(val));

  function populateSidePanelLayoutComponents(component) {
    let content = '';
    if (component.content) {
      component.content.forEach((v, idx) => {
        content += `
          <div class='component-content' > 
            <div style='display: flex; justify-content: space-between; align-items: center; padding: 4px'> 
              <h4>Content ${idx + 1}</h4>
              <div style='display: flex; float: right'>
                <div style='cursor: pointer; padding: 3px 6px' onclick="toggleExpand(${component.id}, 'container', ${idx})">T</div>
                <div style='cursor: pointer; padding: 3px 6px' onclick="deleteElement(${component.id}, ${idx}, 'content')">D</div>
              </div>
            </div>
            <div class='content ${v.elementExpanded ? '' : 'active'}'>
              ${extractComponentOptions(component.id, 'options', v.options, idx)}
              ${extractComponentOptions(component.id, 'media', v.media, idx)}
              ${extractComponentOptions(component.id, 'text', v.text, idx)}
            </div>
          </div>`
      })
    }

    $('.side-panel .layout').append(`
      <div class="component" id='${component.id}'>
        <div class='header'>
          <h3 style='display: inline'>${component.componentType.replace('_', ' ')}</h3>
          <div class='options'>
            <div class='option scroll-to-component' onclick="scrollToComponent(${component.id})">S</div>
            <div class='option expand-component' onclick="toggleExpand(${component.id}, 'component')">T</div>
            <div class='option delete-component' onclick="deleteComponent(${component.id})">D</div>
          </div>
        </div>
        <div class='component-container ${component.expanded ? 'active' : ''}'> 
          ${component.options ? `
            <div class='component-content' >
              ${extractComponentOptions(component.id, 'container options', component.options)}
              ${extractComponentOptions(component.id, 'media', component.media)}
              ${extractComponentOptions(component.id, 'text', component.text)}
            </div>` : ''}
          ${content}
          ${component.componentType !== 'PARALLAX' ?
        ` <button style='padding: 4px 8px; cursor: pointer;' onclick="addMoreContent(${component.id}, '${component.componentType}')">
              Add more content
            </button>` : ''}
        </div>
      </div>`);
  }

  function populateStaticSidePanelControls() {
    //? ---------------- color picker -----------------
    let content = ''

    Object.entries(DESIGN_COLOR_VARIABLES)
      .forEach(([k, v]) => {
        $('.wrapper-body').css({ [k]: v });
      })

    Object.entries(DESIGN_COLOR_VARIABLES)
      .forEach(([k, v]) => {
        content += `
          <div class='theme-color'>
            <label for="${k}">${k.replaceAll('-', ' ')}</label>
            <input type='color' oninput='updateColor(this, "${k}")' value="${v}" />
          </div>
          `
      })

    $('.design').append(content);

    //? --------------- add components ----------------
    let templates = '';

    COMPONENTS_TYPES.forEach(template => {
      templates += `<option value='${template}'>${template}</option>`
    });

    const components = `
      <label for="media">Add Component:</label>
      <select onchange="addComponent(this)">
        <option value="" selected disabled>Choose here</option>
        ${templates}
      </select>`

    $('.side-panel .controls').append(`
      ${components}
      <div class="button copy" onclick="copyInnerHTMLToClipboard('wrapper')">
        Copy to Clipboard
      </div>
      ${localStorageComponents ? `
        <div class="button clearStoredComponents" onclick="clearFromLocalStorage('StoredComponents')">
          Clear Local Storage
        </div>` : ''}
    `);
  }

  document.addEventListener('DOMContentLoaded', function () {
    const components = COMPONENTS_DATA;

    domInit(components)
    initSidePanel(components);
    populateStaticSidePanelControls();
    checkExpandableElement(components);

  });

  $('.layout').sortable({
    cancel: '.layout .component-container',
    cursor: 'grabbing',
    opacity: .8,
    update: function (event, ui) {
      const newLayoutOrder = $(this).sortable("toArray")

      COMPONENTS_DATA.sort((a, b) => {
        return newLayoutOrder.indexOf(a.id.toString()) - newLayoutOrder.indexOf(b.id.toString())
      })

      EMPTYDOMCOMPONENTS(COMPONENTS_DATA)
      REPOPULATEDOM(COMPONENTS_DATA)
      scrollToComponent(ui.item[0].id)
    }
  });

  function copyInnerHTMLToClipboard(componentID) {
    const element = document.getElementById(componentID);

    if (element) {
      const textarea = document.createElement('textarea');
      const innerHTML = element.innerHTML
        .replaceAll('contenteditable="true"', '')
        .replaceAll(' componentExpanded', '')
        .replaceAll(' targetableElement', '')
        .replace(/component-id="[^"]*"/g, '');

      textarea.value = innerHTML;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);

      alert('HTML copied')
    } else {
      console.error(`Element with ID '${componentID}' not found.`);
    }
  }
</script>

<!-- TODO --------- media url - should have another variation? video for desktop but image for mobile ?-->

<!-- ! --------- theme palette - invidual colours per component? or double of each style for variations -->