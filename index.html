<!-- !----------------------------------------------------- -->
<!-- !--------- APP SAMPLES CONTENT AND COMPONENTS -------- -->
<script>
  const SKEW_OPTIONS = ['a', 'b', 'c', 'd', 'none'];
  const TEXT_TYPES = ['primary-header-text', 'secondary-header-text', 'primary-body-text'];
  const COMPONENTS_TYPES = ['HEADER', 'FIXED', 'PARALLAX'];

  /**
   * Generates unique ID of specified length.
   * @param {number} length - The length of the unique ID. Default is 3.
   * @returns {number} - The generated unique ID.
   */
  const generateUniqueId = (length = 4) => {
    return parseInt(Math.ceil(Math.random() * Date.now()).toPrecision(length).toString().replace(".", ""))
  }

  /**
   * Generates a random boolean value.
   * @returns {boolean} - The generated boolean value.
   */
  const booleanGenerator = () => Math.random() >= 0.5;

  /**
   * Retrieves the color variables from local storage or returns default color variables.
   * @returns {object} - The color variables object.
   */
  const DESIGN_COLOR_VARIABLES =
    JSON.parse(localStorage.getItem('ColorVariables'))
    || {
      ['--primary-text-color']: '#F0ECE5',
      ['--secondary-text-color']: '#B6BBC4',
      ['--description-text-color']: '#949ca9',
      ['--primary-background-color']: '#191919',
    };

  /**
   * Retrieves a sample text.
   * @returns {array} - An array of sample text objects.
   */
  const GET_SAMPLE_TEXT = () => {
    const sample_text = [
      "Lorem, ipsum dolor sit amet consectetur adipisicing elit. Corporis mollitia ut sunt nulla ullam eum sed odio dolorem rem, laboriosam, suscipit facilis soluta assumenda nesciunt ratione. Sequi similique ab consectetur!",
      "Nulla architecto veniam rem voluptas, vitae nihil saepe sunt aliquam animi atque laboriosam molestias voluptates, pariatur corrupti perspiciatis tempora. Eum voluptate illo cum iusto aliquam voluptatem distinctio inventore ab iure.",
      "Cum rerum et, iusto placeat adipisci ut! Eveniet labore incidunt dolor vel est culpa ut velit accusamus dignissimos voluptatibus ipsa laudantium pariatur ullam tempora, porro dicta eius quos cumque nam!",
      "Vero exercitationem adipisci corrupti sapiente error. Voluptas veritatis porro harum voluptates repudiandae vel nam iure minima nisi! Molestiae esse asperiores dignissimos voluptatum dolorem rerum tenetur amet. Amet adipisci pariatur mollitia.",
      "Iusto necessitatibus impedit qui ducimus culpa assumenda neque blanditiis corrupti odio perspiciatis. Veniam quas quia accusamus nobis nihil praesentium debitis repellendus nostrum doloremque nemo. Accusamus itaque nemo amet provident tempore?",
      "Iure natus ipsa minus quas, blanditiis inventore cupiditate officia iusto pariatur autem voluptates aliquid nisi temporibus voluptatum eum harum obcaecati quidem voluptate. Temporibus odio, explicabo minus in consequatur obcaecati laborum.",
      "Ducimus commodi rem, et sapiente delectus aspernatur, qui ratione hic ullam quisquam deleniti sint, recusandae vel consequatur mollitia doloremque. Nam, fugiat. Labore laudantium dolor quaerat officia rem animi ab cupiditate?",
      "Architecto, laborum maxime voluptatibus consequatur delectus odit at! Aliquam porro sapiente sequi obcaecati nulla, ea blanditiis eveniet earum praesentium reprehenderit deleniti debitis totam doloribus soluta explicabo perferendis. Amet, impedit fugit.",
      "Iste delectus reprehenderit itaque, eligendi soluta dolorum esse quia mollitia at! Provident corporis nam impedit saepe quas quibusdam deleniti, reiciendis earum perferendis pariatur qui cupiditate. Consequatur eaque error voluptatibus blanditiis.",
      "Praesentium vitae earum minima in quis eaque pariatur, optio officia repellat quae possimus unde repellendus, beatae deleniti, harum autem sequi nulla itaque. Fugit soluta eaque omnis amet quasi accusantium hic!"
    ]

    return [
      {
        ['primary-header-text']: sample_text[Math.floor(Math.random() * sample_text.length)].slice(0, Math.max(30, Math.floor(Math.random() * 60)))
      },
      ...Array.from({ length: Math.max(1, Math.floor(Math.random() * 3)) }, () => {
        return {
          ['primary-body-text']: sample_text[Math.floor(Math.random() * sample_text.length)]
        }
      })
    ]
  }

  /**
   * Retrieves a sample media.
   * @returns {object} - The sample media object.
   */
  const GET_SAMPLE_MEDIA = () => {
    const sample_media = [
      {
        type: 'image',
        url: 'https://images.unsplash.com/photo-1470252649378-9c29740c9fa8?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
        description: ''
      },
      {
        type: 'image',
        url: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?q=80&w=2074&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-landscape-of-a-large-lake-during-sunset-from-the-air-4998-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-meadow-surrounded-by-trees-on-a-sunny-afternoon-40647-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-turquoise-blue-water-bay-from-above-5008-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-aerial-shot-of-a-small-isthmus-44399-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-countryside-meadow-4075-large.mp4',
        description: ''
      }, {
        type: 'video/mp4',
        url: 'https://assets.mixkit.co/videos/preview/mixkit-landscape-of-a-lake-during-a-red-sunset-5002-large.mp4',
        description: ''
      }
    ]

    return sample_media[Math.floor(Math.random() * sample_media.length)];
  }

  /**
   * Generates the content for different components based on the component type.
   * @param {string} componentType - The type of the component.
   * @returns {object} - The generated content object.
   */
  const COMPONENTS_CONTENT_GENERATOR = (componentType) => {
    switch (componentType) {
      case 'HEADER':
        return {
          options: {
            blur: booleanGenerator(),
            shadow: booleanGenerator(),
            textAnimation: booleanGenerator(),
            textContainer: booleanGenerator(),
          },
          media: GET_SAMPLE_MEDIA(),
          text: GET_SAMPLE_TEXT()
        }
      case 'FIXED':
        return {
          options: {
            insetShadow: booleanGenerator(),
            textAnimation: booleanGenerator(),
          },
          media: GET_SAMPLE_MEDIA(),
          text: GET_SAMPLE_TEXT()
        }
      case 'PARALLAX':
        return {
          options: {
            blur: booleanGenerator(),
            shadow: booleanGenerator(),
            textAnimation: booleanGenerator(),
          },
          media: GET_SAMPLE_MEDIA(),
          text: GET_SAMPLE_TEXT()
        }
    }
  };

  /**
   * Generates the object for different components based on the component type.
   * @param {string} componentType - The type of the component.
   * @returns {object} - The generated component object.
   */
  const COMPONENTS_OBJECT_GENERATOR = (componentType) => {
    switch (componentType) {
      case 'HEADER':
        return {
          id: generateUniqueId(),
          componentType: componentType,
          expanded: false,
          content: Array.from({ length: 5 }, () => COMPONENTS_CONTENT_GENERATOR(componentType))
        }
      case 'FIXED':
        return {
          id: generateUniqueId(),
          expanded: false,
          componentType: componentType,
          options: {
            skew: SKEW_OPTIONS[Math.floor(Math.random() * SKEW_OPTIONS.length)],
            shadow: booleanGenerator(),
            flex: booleanGenerator(),
          },
          content: Array.from({ length: 3 }, () => COMPONENTS_CONTENT_GENERATOR(componentType))
        }
      case 'PARALLAX':
        return {
          id: generateUniqueId(),
          componentType: componentType,
          expanded: false,
          ...COMPONENTS_CONTENT_GENERATOR(componentType)
        }
    }
  };

  /**
   * Retrieves the stored components from local storage or generates new components.
   * @returns {array} - An array of components.
   */
  const localStorageComponents = JSON.parse(localStorage.getItem('StoredComponents'));
  let COMPONENTS_DATA =
    localStorageComponents ||
    COMPONENTS_TYPES.map(component => COMPONENTS_OBJECT_GENERATOR(component));
</script>

<!-- !----------------------------------------------------- -->
<!-- !------------------- APP STYLES ---------------------- -->
<style type="text/css">
  .app .side-panel::-webkit-scrollbar {
    width: 8px;
  }

  .app .side-panel::-webkit-scrollbar-track {
    background: var(--primary-background-color);
  }

  .app .side-panel::-webkit-scrollbar-thumb {
    background: var(--description-text-color);
  }

  * {
    padding: 0;
    margin: 0;
    box-sizing: border-box;
  }

  .app {
    display: flex;
    overflow: hidden;
    height: 100vh;
  }

  .app #wrapper {
    width: 100%;
    height: 100%;
    overflow: auto;
    overflow-y: overlay;
  }

  .app .side-panel {
    position: sticky;
    background: #191919;
    min-width: 400px;
    box-shadow: 0 0 8px black;
    z-index: 9999999999;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    max-width: 500px;
    overflow-y: scroll;
    color: white;
    padding-left: 5px;
  }

  .app .side-panel .controls {
    margin-top: auto;
  }

  .app .side-panel .design {
    padding: 10px;
    border-radius: 8px;
    margin: 5px;
    background-color: rgb(43, 42, 42);
  }

  .app .side-panel .design .theme-color {
    margin: 0 40px;
    text-transform: capitalize;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .app .side-panel .layout .component {
    margin: 10px 5px;
    background-color: rgb(43, 42, 42);
    padding: 10px;
    border-radius: 8px;
    border: 2px solid #8080806b;
  }

  .app .side-panel .layout .component .component-container {
    display: none;
  }

  .app .side-panel .layout .component .component-container.active {
    display: block;
    padding: 0;
  }

  .app .side-panel .layout .component .component-container .component-content {
    padding: 5px;
    margin: 10px 0;
    background-color: #191919;
    border: 2px solid #8080806b;
    border-radius: 5px;
  }

  .app .side-panel .layout .component .component-container .component-content .options {
    padding: 5px;
    border: 2px solid grey;
    border-radius: 5px;
    margin: 5px 0;
  }

  .app .side-panel .layout .component .component-container .component-content .options button {
    padding: 2px 4px;
    cursor: pointer;
  }

  .app .side-panel .layout .component .component-container .component-content .options h4 {
    text-transform: capitalize;
    padding: 5px 0;
  }

  .button {
    background: grey;
    margin: 5px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
  }
</style>

<!-- !----------------------------------------------------- -->
<!-- !-------------------- DOM BODY ----------------------- -->
<div class="app">
  <div id="wrapper">
    <style type="text/css">
      :root {
        --primary-text-color: #F0ECE5;
        --secondary-text-color: #B6BBC4;
        --description-text-color: #949ca9;

        --primary-background-color: #191919;
        --secondary-background-color: #3a5a40;

        --background-blend-delay: .5s;
        --text-animation-delay: 1s;

        --content-max-width: 1000px;
      }

      /* ----- global text ----- */
      .primary-header-text {
        color: var(--primary-text-color);
        padding: 15px 20px;
        margin: 0;
        font-size: 28px;
      }

      .secondary-header-text {
        color: var(--primary-text-color);
        font-size: 22px;
        padding: 15px 20px;
      }

      .primary-body-text {
        margin: 0;
        padding: 10px 20px;
        color: var(--secondary-text-color);
        font-size: 16px;
      }

      .description {
        font-size: 16px;
        color: var(--description-text-color);
        padding: 10px 30px;
      }

      .parallax .description,
      .parallax-header .description {
        position: absolute !important;
        bottom: 20px !important;
        right: 20px;
      }

      .wrapper-body {
        background-color: var(--primary-background-color);
      }

      /* ----- splash laoder ----- */
      .loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        z-index: 999999999;
        backdrop-filter: blur(10px);
        background-color: var(--primary-background-color);
        opacity: 1;
        transition: all 1s ease-in;
      }

      .loader.disabled {
        opacity: 0;
        backdrop-filter: blur(0);
      }

      /* ----- animation classes ----- */
      .animate-bg-shadow:after,
      .animate-bg-blur:after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .animate-bg-shadow:after {
        background: rgba(0, 0, 0, .5);
        opacity: 0;
        transition: opacity var(--background-blend-delay) ease-in;
      }

      .animate.animate-bg-shadow:after {
        opacity: 1;
      }

      .animate-bg-blur:after {
        -webkit-backdrop-filter: blur(0px);
        backdrop-filter: blur(0px);
        transition: all var(--background-blend-delay) ease-in;
      }

      .animate.animate-bg-blur:after {
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }

      .observe.secondary-header-text,
      .observe.primary-header-text {
        transform: translate3d(-100%, 0, 0);
        opacity: .5;
        transition: all var(--text-animation-delay) ease;
      }

      .animate.secondary-header-text,
      .animate.primary-header-text {
        transform: translate3d(0, 0, 0);
        opacity: 1;
      }

      .out.secondary-header-text:not(.animate),
      .out.primary-header-text:not(.animate) {
        transform: translate3d(100%, 0, 0);
        opacity: 1;
      }

      .observe.primary-body-text {
        transform: translate3d(-100%, 0, 0);
        opacity: .5;
        transition: all var(--text-animation-delay) ease;
      }

      .animate.primary-body-text {
        transform: translate3d(0, 0, 0);
        opacity: 1;
      }

      .out.primary-body-text:not(.animate) {
        transform: translate3d(100%, 0, 0);
        opacity: 1;
      }

      /* ---------------- header ---------------- */
      .parallax-header {
        position: relative;
      }

      .parallax-header .text-content {
        margin-top: -100vh;
      }

      .parallax-header .background-content {
        position: sticky;
        top: 0px;
        height: 100vh;
      }

      .parallax-header .background-content .media img,
      .parallax-header .background-content .media video {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        transform: translate(-50%, -50%);
        -o-object-fit: cover;
        object-fit: cover;
        -o-object-position: center;
        object-position: center;
      }

      .parallax-header .text-content .text {
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2em;
        position: relative;
        overflow: hidden;
      }


      .parallax-header .text-content .text.animate .container {
        opacity: 1;
        width: 80%;
      }

      /*========================================  */
      /* !------------------------------------------------*/
      /* !---------- Animation for the container? --------*/
      /* .parallax-header .text-content .text.animate .container {
        opacity: 0;
        transform: translateY(-50vw);
        transition: all 1s ease-in;
      }

      .parallax-header .text-content .text.animate .container.active {
        opacity: 1;
        transform: translateY(0);
      } */

      .parallax-header .text-content .text.animate .container.active {
        opacity: 1;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
        padding: 10px 20px;
        min-width: 300px;
        max-width: 600px;
      }

      /*========================================  */

      .parallax-header .text-content .text.out:not(.animate) .container {
        transform: translateY(-20vw);
        opacity: 0;
      }

      /* ---------------- fixed ---------------- */
      .fixed {
        z-index: 2;
        position: relative;
      }

      .fixed.shadow {
        filter: drop-shadow(0 0 12px rgba(0, 0, 0, .8));
      }

      .fixed .container {
        width: 100%;
        height: fit-content;
        background: var(--primary-background-color);
        padding: 20px 0;
        overflow: hidden;
      }

      .fixed .container .content {
        width: 100%;
        margin: 0 auto;
        max-width: var(--content-max-width);
      }

      .fixed .container .flex {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        flex-direction: row;
        justify-content: center;
        gap: 25px;
        max-width: var(--content-max-width);
        margin: 0 auto;
      }

      .fixed .container .flex .content {
        flex: 1 1 400px;
      }

      .fixed .container .content video,
      .fixed .container .content img {
        width: 100%;
      }

      .fixed .container.cliped {
        padding: 90px 0;
        /* top must match the clipped negative margin */
        margin: -80px 0 -80px 0;
      }

      .fixed .container.cliped.clip-a {
        clip-path: polygon(0 75px, 100% 0, 100% calc(100% - 75px), 0% 100%);
      }

      .fixed .container.cliped.clip-b {
        clip-path: polygon(0 0, 100% 75px, 100% 100%, 0 calc(100% - 75px));
      }

      .fixed .container.cliped.clip-c {
        clip-path: polygon(0 0, 100% 75px, 100% calc(100% - 75px), 0 100%);
      }

      .fixed .container.cliped.clip-d {
        clip-path: polygon(0 75px, 100% 0, 100% 100%, 0 100%);
        padding: 40px 0;
      }

      /* ---------------- parallax ---------------- */
      .parallax {
        position: relative;
        width: 100%;
        height: 100vh;
        overflow: hidden;
      }

      .parallax .content {
        position: absolute;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        clip: rect(0 auto auto 0);
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
      }

      .parallax .content .media {
        position: fixed;
        top: 0;
        left: 0;
        display: block;
        width: 100%;
        height: 100%;
        background-repeat: no-repeat;
        background-attachment: scroll;
        background-position: 50%;
        background-size: cover;
      }

      .parallax .content .text {
        position: absolute;
        top: 50%;
        left: 50%;
        z-index: 1;
        box-sizing: border-box;
        width: 100%;
        max-width: var(--content-max-width);
        padding: 0 10px 0 15px;
        margin: 0 auto;
        transform: translate(-50%, -50%);
      }

      .parallax .content .media img,
      .parallax .content .media video {
        -o-object-fit: cover;
        object-fit: cover;
        -o-object-position: center center;
        object-position: center center;
        width: 100%;
        height: 100vh;
      }

      @media only screen and (min-width: 600px) {
        .primary-header-text {
          font-size: 32px;
        }

        .secondary-header-text {
          font-size: 24px;
        }

        .primary-body-text {
          font-size: 18px;
        }

        .fixed .content .media {
          position: relative;
        }

        .fixed .content .media.insetShadow:after {
          content: '';
          top: 0;
          left: 0;
          position: absolute;
          width: 100%;
          height: 100%;
          box-shadow: inset 0 0 8px 20px var(--primary-background-color);
        }
      }
    </style>
    <div class="wrapper-body">
      <div class="loader"></div>
    </div>

    <script>
      function initObserver() {
        function handleIntersection(entries, observer) {
          entries.forEach(entry => {
            const target = entry.target;
            const inViewPercent = entry.intersectionRatio;
            const opacityVal = inViewPercent > 0.90 ? 1 : inViewPercent;

            const boundingBox = entry.target.getBoundingClientRect();
            const elementCenter = boundingBox.top + boundingBox.height / 2;
            const viewportCenter = window.innerHeight / 2;

            if (elementCenter < viewportCenter) {
              target.classList.add('out');
              target.classList.remove('in');
            } else {
              target.classList.add('in');
              target.classList.remove('out');
            }

            const headerParallaxBackground = target.id ? document.querySelector(`#${target.id}`) : null;

            if (headerParallaxBackground) {
              if (target.classList.contains('control-opacity') && target.classList.contains('in')) {
                headerParallaxBackground.style.opacity = opacityVal;
              }
            }

            if (entry.isIntersecting) {
              target.classList.add('animate');
              headerParallaxBackground && headerParallaxBackground.classList.add('animate');
            } else {
              target.classList.remove('animate');
              headerParallaxBackground && headerParallaxBackground.classList.remove('animate');
            }
          });
        }

        const options = {
          threshold: Array.from({ length: 41 }, (_, index) => Number((index * 0.025).toFixed(2))),
        };

        const observer = new IntersectionObserver(handleIntersection, options);

        document.querySelectorAll('.observe').forEach(function (el) {
          observer.observe(el);
        });
      }

      document.addEventListener('DOMContentLoaded', function () {
        initObserver();

        const loader = document.querySelector('.loader');
        setTimeout(() => loader.classList.add('disabled'), 100);
        setTimeout(() => loader.remove(), 1100);
      })
    </script>
  </div>

  <div class="side-panel">
    <div class="design"></div>
    <div class="layout"></div>
    <div class="controls"></div>
  </div>
</div>

<!-- !----------------------------------------------------- -->
<!-- !---------------- APP DOM GENERATOR ------------------ -->
<script>
  function extractTextContent(data, observe = false) {
    let INNERTEXT = '';

    if (!data) return '';

    data.forEach(text => {
      const [key, value] = Object.entries(text)[0];
      INNERTEXT += `<div contenteditable="true" class='${key} ${observe ? 'observe' : ''}'>${value}</div>`;
    });
    return INNERTEXT;
  }

  function populateMediaContent(data, options) {
    const insetShadow = options?.insetShadow;
    if (!data || !data.url) return '';
    const mediaDescription = data.description ? `<p contenteditable="true" class="description">${data.description}</p>` : '';

    const mediaContent = data.type?.includes('video')
      ? `<div class="media${insetShadow ? ' insetShadow' : ''}">
            <video autoplay loop muted playsinline preload="none" loading="lazy">
              <source src="${data.url}" type="${data.type}" />Your browser does not support the video tag.
            </video>
          </div>`
      : `
          <div class="media${insetShadow ? ' insetShadow' : ''}">
            <img alt="${data.description}" src="${data.url}" preload="none" loading="lazy" decoding="async"/>
          </div>`;

    return `<div class='media-content'>${mediaContent}${mediaDescription}</div>`
  }

  function exctractFixedContent(data) {
    let CONTENT = '';
    data.content.forEach(val => {
      CONTENT += `
        <div class='content'>
          ${populateMediaContent(val.media, val.options)}
          <div class='text'>
            ${extractTextContent(val.text, val.options?.textAnimation)}
          </div>
        </div>`
    });
    return CONTENT;
  }

  function initDOMcontentData(components) {
    const wrapper = document.querySelector('.wrapper-body');

    let __DOM__ = '';

    for (let component of components) {
      switch (component.componentType) {
        case 'HEADER':
          let BACKGROUND = '', CONTENT = '';

          component.content.forEach((val, idx) => {
            const shadow = val.options?.shadow ? ' animate-bg-shadow' : '';
            const blur = val.options?.blur ? ' animate-bg-blur' : '';
            BACKGROUND += `
              <div class='background${shadow}${blur}' id='o${component.id}-${idx}'>
                ${populateMediaContent(val.media, val.options)}
              </div>`;
            CONTENT += `
              <div class='text observe${idx ? ' control-opacity' : ''}' id='o${component.id}-${idx}'>
                ${val.text?.length ? `
                  <div class="container ${val.options?.textContainer ? 'active' : ''}">
                    ${extractTextContent(val.text, val.options?.textAnimation)}
                  </div>
                `: ''}
              </div>`;
          });

          __DOM__ += `
            <div class='parallax-header' container-id='${component.id}'>
              <div class='background-content'>${BACKGROUND}</div>
              <div class='text-content'>${CONTENT}</div>
            </div>`;
          break;

        case 'FIXED':
          const skew = component.options.skew === 'none'
            ? false
            : component.options.skew;
          const containerShadow = component.options.shadow
          const containerFlex = component.options.flex

          const containerClasses = `${skew ? ` cliped clip-${skew}` : ''}`
          __DOM__ += `
            <div class='fixed${containerShadow ? ' shadow' : ''}' container-id='${component.id}'>
              <div class="container${containerClasses}" ${skew === 'd' ? 'style="margin-bottom: 0"' : ''}>
                ${containerFlex 
                  ? `<div class='flex'>
                      ${exctractFixedContent(component)}
                    </div>` 
                  : exctractFixedContent(component)}
              </div>
            </div>`;
          break;

        case 'PARALLAX':
          const shadow = component.options.shadow ? ' animate-bg-shadow' : '';
          const blur = component.options.blur ? ' animate-bg-blur' : '';

          __DOM__ += `
            <div class="parallax" container-id='${component.id}'>
              <div class="content observe${shadow}${blur}">
                ${populateMediaContent(component.media)}
                ${component.text ? `
                  <div class="text">
                    ${extractTextContent(component.text, component.options.textAnimation)}
                  </div>
                  ` : ''}
              </div>
            </div>`;
          break;
      }
    }

    wrapper.insertAdjacentHTML('afterbegin', __DOM__);
  }

  function domInit(data) {
    initDOMcontentData(data)
    initObserver();
  }
</script>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

<!-- !----------------------------------------------------- -->
<!-- !------------------- APP CONTROLS -------------------- -->
<script>
  function EMPTYDOMCOMPONENTS() {
    $('.side-panel .layout').empty();
    $('.wrapper-body').empty();
  }

  function REPOPULATEDOM() {
    const components = COMPONENTS_DATA;
    localStorage.setItem('StoredComponents', JSON.stringify(components));
    initSidePanel(components);
    domInit(components)
  }

  function clearFromLocalStorage(item) {
    switch (item) {
      case 'StoredComponents':
        $('.clearStoredComponents').remove()
        localStorage.removeItem(item)
        break;
      case 'ColorVariables':

        break;
    }
  }

  const deleteElement = (componentID, elementIndex, elementType, textIndex) => {
    const components = COMPONENTS_DATA;
    const componentIndex = components.findIndex(x => x.id === componentID)

    EMPTYDOMCOMPONENTS();

    if (elementType === 'content') {
      components[componentIndex].content.splice(elementIndex, 1);
    } else if (elementType === 'text' && textIndex !== undefined) {
      if (components[componentIndex].content) {
        components[componentIndex].content[elementIndex][elementType].splice(textIndex, 1)
      } else {
        components[componentIndex][elementType].splice(textIndex, 1)
      }
    } else {

      // ? -------------- got to be a better way right ???? -------------
      // ! --------------------------------------------------------------
      if (elementIndex !== undefined) {
        delete components[componentIndex].content[elementIndex][elementType.toLowerCase()];
      } else {
        delete components[componentIndex][elementType.toLowerCase()];
      }
    }

    REPOPULATEDOM()
  }

  const addAdditionalText = (componentID, textType, textIndex) => {
    const components = COMPONENTS_DATA;
    const target = components[components.findIndex(x => x.id === Number(componentID))]

    if (target.text) {
      target.text.push({ [textType.value]: 'Text here...' })
    } else {
      target.content[textIndex].text.push({ [textType.value]: 'Text here...' })
    }

    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const updateComponentValues = (componentID, dataType, key, newValue, elementIndex, textIndex) => {
    const targetObject = COMPONENTS_DATA.find(x => x.id === componentID);

    let targetElement;

    // console.log('componentID', componentID, 'dataType', dataType, 'key', key, 'newValue', newValue, 'elemidx', elementIndex, 'textIndex', textIndex)
    // ------ honestly not the best way but it works for now
    if (elementIndex !== undefined) {
      targetElement = targetObject.content[elementIndex][dataType];
    } else {
      targetElement = targetObject[dataType];
    }

    EMPTYDOMCOMPONENTS();

    switch (dataType) {
      case 'options':
      case 'container options':
        if (typeof targetElement[key] === 'boolean') {
          targetElement[key] = !targetElement[key];
        } else {
          targetElement[key] = newValue;
        }
        break;
      case 'text':
        targetElement[textIndex][key] = newValue.value;
        break;
      case 'media':
        targetElement[key] = newValue;
        break;
    }

    REPOPULATEDOM();
  }

  const addComponent = (selectedElement) => {
    COMPONENTS_DATA.push(COMPONENTS_OBJECT_GENERATOR(selectedElement.value));
    selectedElement.value = ''

    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const deleteComponent = (componentID) => {
    const components = COMPONENTS_DATA;
    const targetIndex = components.findIndex(x => x.id === Number(componentID));

    components.splice(targetIndex, 1)
    $(`[component-id="${componentID}"]`).remove();
    $(`[container-id="${componentID}"]`).remove();

    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const scrollToComponent = (componentID) => {
    const container = document.querySelector(`[container-id="${componentID}"]`);
    if (container) {
      container.scrollIntoView({ behavior: 'smooth' });
    }
  }

  const addMoreContent = (componentID, componentType) => {
    const components = COMPONENTS_DATA;
    const target = components[components.findIndex(x => x.id === Number(componentID))];

    target.content.push(COMPONENTS_CONTENT_GENERATOR(componentType))
    EMPTYDOMCOMPONENTS();
    REPOPULATEDOM();
  }

  const toggleExpand = (componentID) => {
    const components = COMPONENTS_DATA;
    components.forEach(x => {
      if (componentID !== x.id) x.expanded = false;
      else x.expanded = !x.expanded;
    });

    //! ------------- find better approach to deal with repainting 
    localStorage.setItem('StoredComponents', JSON.stringify(components));
    $('.side-panel .layout').empty();
    initSidePanel(components);
  }

  const updateColor = (data, target) => {
    DESIGN_COLOR_VARIABLES[target] = data.value
    $('.wrapper-body').css(target, data.value)

    localStorage.setItem('ColorVariables', JSON.stringify(DESIGN_COLOR_VARIABLES));
  }

  const extractComponentFields = (componentID, title, data, elementIndex) => {
    if (!data) return ''

    let content = '';

    if (['media', 'container options', 'options'].includes(title)) {
      Object.entries(data).forEach(([key, value]) => {
        switch (key) {
          // ! ---------- boolean values
          case 'blur':
          case 'shadow':
          case 'textContainer':
          case 'insetShadow':
          case 'flex':
          case 'textAnimation':
            content += `
                <p>${key}: <button onclick="updateComponentValues(${componentID}, 'options', '${key}', ${!value}, ${elementIndex})">${value}</button></p>`;
            break;

          //! =------------ dropdown values
          case 'type':
          case 'skew':
            const options = key === 'skew'
              ? SKEW_OPTIONS
              : ['image', 'video/mp4'];

            let dataType = title;
            if (title === 'container options') dataType = 'options'; //? unique case --- 

            let optionsDom = '';
            options.forEach(val => {
              optionsDom += `
                <option value=${val} ${val === data[key] ? 'selected' : ''}>${val}</option>`
            })

            content += `
                <label for="${key}">${key}:</label>
                <select onchange="updateComponentValues(${componentID}, '${dataType}', '${key}', this.options[this.selectedIndex].value, ${elementIndex})">
                  ${optionsDom}
                </select>
              `
            break;

          // ! ---------- string values 
          case 'description':
          case 'url':
            content += `
              <div>
                <p style='display: inline-block'>${key}:</p>
                <input type="text" value="${value}" onchange="updateComponentValues(${componentID}, '${title}', '${key}', this.value, ${elementIndex})">
              </div>`
            break;
        }
      })
    }

    if (title === 'text' && Array.isArray(data)) {
      data.forEach((text, idx) => {
        const [key, value] = Object.entries(text)[0];
        content += `
            <div style="padding: 5px 0;" ${idx}> 
              <label for="text">${key}:</label>
              <input type="text" value="${value}" onchange="updateComponentValues(${componentID}, 'text', '${key}', this, ${elementIndex}, ${idx})">
              <button style='float: right;' onclick="deleteElement(${componentID}, ${elementIndex}, 'text', ${idx})">x</button>
            </div>
          `
      })
    }

    let textOptions = ''
    TEXT_TYPES.forEach(x => {
      textOptions += `<option value='${x}'>${x}</option>`
    })

    return `
        <div class="options ${title.toLowerCase().replace(' ', '-')}">
          <h4>${title} ${title !== 'Container Options' ?
        `<button style="float: right;" onClick='deleteElement(${componentID}, ${elementIndex}, "${title}")'>x</button>` : ''}</h4> 
          ${content}
          ${title === 'text'
        ? `
            <label for="${title}">Add Text:</label>
            <select onchange="addAdditionalText(${componentID}, this, ${elementIndex})">
              <option value="" selected disabled>Choose here</option>
              ${textOptions}
            </select>

            `
        : ''}
        </div>`
  }

  const initSidePanel = (data) => data.forEach((val, idx) => populateSidePanelLayoutComponents(val));

  function populateSidePanelLayoutComponents(component) {
    let content = '';
    if (component.content) {
      component.content.forEach((v, idx) => {
        content += `
          <div class='component-content'>
            ${extractComponentFields(component.id, 'options', v.options, idx)}
            ${extractComponentFields(component.id, 'media', v.media, idx)}
            ${extractComponentFields(component.id, 'text', v.text, idx)}
          ${component.componentType !== 'PARALLAX' ? `<button style="margin-top: 5px 10px; display: block;" onclick="deleteElement(${component.id}, ${idx}, 'content')">Delete Element</button>` : ''}
          </div>
        `
      })
    }

    $('.side-panel .layout').append(`
      <div class="component" component-id="${component.id}">
        <div class='header'>
          <h3 style='display: inline'>${component.componentType}</h3>
          <div class='delete-component' onclick="deleteComponent(${component.id})" style='cursor: pointer; display: inline-block; padding: 5px 10px; float: right;'>D</div>
          <div class='expand-component' onclick="toggleExpand(${component.id})" style='cursor: pointer; display: inline-block; padding: 5px 10px; float: right;'>T</div>
          <div class='scroll-to-component' onclick="scrollToComponent(${component.id})" style='cursor: pointer; display: inline-block; padding: 5px 10px; float: right;'>S</div>
        </div>

        <div class='component-container ${component.expanded ? 'active' : ''}'> 
          ${component.options ? `
            <div class='component-content' >
              ${extractComponentFields(component.id, 'container options', component.options)}
              ${extractComponentFields(component.id, 'media', component.media)}
              ${extractComponentFields(component.id, 'text', component.text)}
            </div>` : ''}
          ${content}
          ${component.componentType !== 'PARALLAX' ?
        `<button onclick="addMoreContent(${component.id}, '${component.componentType}')">Add more content</button>` : ''}
        </div>
      </div>`);
  }

  function populateStaticSidePanelControls() {
    //? ---------------- color picker -----------------
    let content = ''

    Object.entries(DESIGN_COLOR_VARIABLES)
      .forEach(([k, v]) => {
        $('.wrapper-body').css({ [k]: v });
      })

    Object.entries(DESIGN_COLOR_VARIABLES)
      .forEach(([k, v]) => {
        content += `
          <div class='theme-color'>
            <label for="${k}">${k.replaceAll('-', ' ')}</label>
            <input type='color' oninput='updateColor(this, "${k}")' value="${v}" />
          </div>
          `
      })

    $('.design').append(content);

    //? --------------- add components ----------------
    let templates = '';

    COMPONENTS_TYPES.forEach(template => {
      templates += `<option value='${template}'>${template}</option>`
    });

    const components = `
      <label for="media">Add Component:</label>
      <select onchange="addComponent(this)">
        <option value="" selected disabled>Choose here</option>
        ${templates}
      </select>`

    $('.side-panel .controls').append(`
      ${components}
      <div class="button copy" onclick="copyInnerHTMLToClipboard('wrapper')">Copy to Clipboard</div>
      ${localStorageComponents ? `<div class="button clearStoredComponents" onclick="clearFromLocalStorage('StoredComponents')">Clear Local Storage</div>` : ''}
    `);
  }

  document.addEventListener('DOMContentLoaded', function () {
    const components = COMPONENTS_DATA;

    domInit(components)
    initSidePanel(components);
    populateStaticSidePanelControls();
  });

  function copyInnerHTMLToClipboard(componentID) {
    const element = document.getElementById(componentID);

    if (element) {
      const textarea = document.createElement('textarea');
      const innerHTML = element.innerHTML
        .replaceAll('contenteditable="true"', '')
        .replace(/container-id="[^"]*"/g, '');

      textarea.value = innerHTML;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);

      alert('HTML copied')
    } else {
      console.error(`Element with ID '${componentID}' not found.`);
    }
  }
</script>

<!-- TODO --------- positions for header containers, containers animated instead of text when animated selected ? ----------- -->
<!-- TODO --------- scroll and highlight selected component --- -->
<!-- TODO --------- dropdown with selecitons for textAnimation --- -->
<!-- TODO --------- draggable components --- -->

<!-- TODO --------- update skew --- -->